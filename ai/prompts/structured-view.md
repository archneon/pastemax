## **Instructions for PasteMax Refactoring: Simplified Structured Prompt Output & UI (Convention-Based)**

**1. Goal Recap**

The primary goal is to enhance PasteMax's "Copy" functionality to produce a structured text output suitable for AI prompts. This output will categorize selected files into predefined sections (Project Tree, Rules, Documentation, Project Files, Prompts) using specific markers. The categorization will rely on directory naming conventions (`ai/rules`, `ai/docs`, etc.). Section descriptions and an optional prompt overview will be sourced from files within a central `ai/.descriptions/` directory.

Additionally, the UI's main file display area will be updated. While the "Flat" view remains, the "Structured" view will visually group selected files according to these predefined sections, using labels and colors defined in constants. Checkboxes will allow users to optionally include the Project Tree and the Prompt Overview in the final output.

This refactoring aims for a cleaner, convention-based approach, minimizing complex configuration.

**2. Target Output Format Example**

The final string generated by the "Copy" button should resemble this structure (actual content depends on user selections and file presence):

```text
==== SYSTEM_PROMPT_OVERVIEW ====
This is the static content read from the 'ai/.descriptions/overview.txt' file.
It is included only if the 'Include Prompt Overview' checkbox is checked.

@@@@ PROJECT_TREE_START
.
├── ai
│   ├── .descriptions
│   │   ├── docs.txt
│   │   ├── overview.txt
│   │   └── rules.txt
│   ├── docs
│   │   └── next-intl.md
│   └── rules
│       └── role.md
└── src
    └── app
        └── layout.tsx
@@@@ PROJECT_TREE_END

@@@@ RULES_START

%%%% DESCRIPTION_START
Content read from 'ai/.descriptions/rules.txt'. Included only if the file exists and has content.
%%%% DESCRIPTION_END

>>>> FILE_START: ai/rules/role.md
# AI Role
You are a senior fullstack developer...
>>>> FILE_END: ai/rules/role.md

@@@@ RULES_END

@@@@ DOCUMENTATION_START

%%%% DESCRIPTION_START
Content read from 'ai/.descriptions/docs.txt'.
%%%% DESCRIPTION_END

>>>> FILE_START: ai/docs/next-intl.md
# Next-Intl Setup
Routing config...
>>>> FILE_END: ai/docs/next-intl.md

@@@@ DOCUMENTATION_END

@@@@ PROJECT_FILES_START

%%%% DESCRIPTION_START
Content read from 'ai/.descriptions/project_files.txt' (if it exists). This section includes all selected files not matching other specific directories.
%%%% DESCRIPTION_END

>>>> FILE_START: src/app/layout.tsx
export default function Layout() { ... }
>>>> FILE_END: src/app/layout.tsx

@@@@ PROJECT_FILES_END

@@@@ PROMPTS_START

%%%% DESCRIPTION_START
Content read from 'ai/.descriptions/prompts.txt'.
%%%% DESCRIPTION_END

>>>> FILE_START: ai/prompts/task.md
# Task: Implement Feature X
...
>>>> FILE_END: ai/prompts/task.md

@@@@ PROMPTS_END
```

**Key Output Rules:**

- **Overview:** Included only if "Include Prompt Overview" is checked AND `ai/.descriptions/overview.txt` exists and has content. No extra wrappers added by code; `overview.txt` should contain them if needed.
- **Project Tree:** Included only if "Include File Tree" is checked. Uses `PROJECT_TREE_CONFIG.name` for markers.
- **Sections (Rules, Docs, etc.):** Included only if at least one _selected_ file belongs to that section. Uses `section.name` for markers. Order follows `PROMPT_SECTIONS` constant.
- **Descriptions:** Included within a section only if the corresponding description file (e.g., `ai/.descriptions/rules.txt`) exists and has content. Uses description markers.
- **Files:** Included within their section using file markers and relative paths.

**3. Implementation Steps**

**Step 1: Define Types**

- **File:** `src/types/promptConfigTypes.ts` (Create this new file)
- **Action:** Define and export the `PromptSectionDefinition` interface.

```typescript
// src/types/promptConfigTypes.ts

export interface PromptSectionDefinition {
  id: string; // Internal identifier (e.g., 'rules', 'docs', 'project_files') - Used as key
  name: string; // Name for markers (e.g., 'RULES', 'DOCUMENTATION')
  label: string; // Name for UI display (e.g., 'Rules', 'Docs')
  directory: string | null; // Relative path from project root for categorization (null for default)
  descriptionFilename: string | null; // Filename within DESCRIPTIONS_DIR (e.g., "rules.txt") or null
  color: string; // CSS color string for UI
}
```

**Step 2: Define Constants**

- **File:** `src/constants.ts`
- **Action:** Replace any old prompt config constants with the new structure. Import the new type. Add necessary constants.

```typescript
// src/constants.ts

// --- Import New Type ---
import { PromptSectionDefinition } from "./types/promptConfigTypes"; // Adjust path if needed

// --- Existing Constants ---
export const LOCAL_STORAGE_KEYS = {
  THEME: "pastemax-theme",
  PROJECT_STATES: "pastemax-project-states", // For per-project settings like selected files, sort, etc.
  LAST_SELECTED_FOLDER: "pastemax-last-selected-folder",
  RECENT_FOLDERS: "pastemax-recent-folders",
  // Global settings (not per-project)
  INCLUDE_PROMPT_OVERVIEW: "pastemax-include-prompt-overview",
  INCLUDE_FILE_TREE: "pastemax-include-file-tree", // <-- ADD this if persisting globally, otherwise handled per-project
};
export const MAX_RECENT_FOLDERS = 10;
export const DEFAULT_SORT_ORDER = "path-asc";
export const DEFAULT_FILE_LIST_VIEW = "structured" as const;
// Defaults for global settings (used in App.tsx useState initial value)
export const DEFAULT_INCLUDE_FILE_TREE_GLOBAL = false; // Or true if preferred default
export const DEFAULT_INCLUDE_PROMPT_OVERVIEW_GLOBAL = false; // Or true if preferred default

export const THEME_OPTIONS = {
  /* ... */
} as const;
export type ThemeValue = (typeof THEME_OPTIONS)[keyof typeof THEME_OPTIONS];
export const FILE_LIST_VIEWS = {
  /* ... */
} as const;
export type FileListViewValue =
  (typeof FILE_LIST_VIEWS)[keyof typeof FILE_LIST_VIEWS];
export const SORT_ORDERS = {
  /* ... */
} as const;
export type SortOrderValue = (typeof SORT_ORDERS)[keyof typeof SORT_ORDERS];

// --- NEW/UPDATED Constants for Structured Prompt ---

// Central directory for all description files and the overview template
export const DESCRIPTIONS_DIR = "ai/.descriptions";

// Filename for the overview template within DESCRIPTIONS_DIR
export const OVERVIEW_FILENAME = "overview.txt";

// Markers (with placeholders)
export const PROMPT_MARKERS = {
  section_open: "@@@@ {section_name}_START",
  section_close: "@@@@ {section_name}_END",
  description_open: "%%%% DESCRIPTION_START",
  description_close: "%%%% DESCRIPTION_END",
  file_open: ">>>> FILE_START: {file_path}",
  file_close: ">>>> FILE_END: {file_path}",
  // No wrappers needed for overview here
};

// Project Tree Configuration (Simplified)
export const PROJECT_TREE_CONFIG = {
  name: "PROJECT_TREE", // Name for markers
  descriptionFilename: "project_tree.txt", // Optional description filename within DESCRIPTIONS_DIR
};

// Section Definitions - ORDER MATTERS for output and structured UI!
// Type PromptSectionDefinition is imported from src/types/promptConfigTypes.ts
export const PROMPT_SECTIONS: PromptSectionDefinition[] = [
  {
    id: "rules", // Used as key and for description lookup
    name: "RULES",
    label: "Rules",
    directory: "ai/rules",
    descriptionFilename: "rules.txt",
    color: "var(--warning-color)",
  },
  {
    id: "docs",
    name: "DOCUMENTATION",
    label: "Docs",
    directory: "ai/docs",
    descriptionFilename: "docs.txt",
    color: "var(--success-color)",
  },
  {
    id: "project_files", // Default section
    name: "PROJECT_FILES",
    label: "Project",
    directory: null, // Indicates this is the default/fallback
    descriptionFilename: "project_files.txt", // Optional description for default files
    color: "var(--accent-blue)",
  },
  {
    id: "prompts",
    name: "PROMPTS",
    label: "Prompts",
    directory: "ai/prompts",
    descriptionFilename: "prompts.txt",
    color: "var(--error-color)",
  },
];
```

**Step 3: Modify Backend File Reading (`main.js`)**

- **File:** `main.js`
- **Action:** Update `readFilesRecursively` to identify description/overview files based on `DESCRIPTIONS_DIR`. Add flags to the file data sent to the renderer. Ensure paths sent to the renderer are normalized.
- **Imports:** `path`, constants (`DESCRIPTIONS_DIR`, `OVERVIEW_FILENAME`, `PROMPT_SECTIONS`).

```javascript
// main.js
const path = require("path");
const {
  app,
  BrowserWindow,
  ipcMain,
  dialog,
  Menu,
  MenuItem,
} = require("electron");
const fs = require("fs");
const os = require("os");
// --- Add/Verify Constants Import ---
const {
  IPC_CHANNELS,
  MAX_FILE_SIZE,
  DESCRIPTIONS_DIR,
  OVERVIEW_FILENAME,
  PROMPT_SECTIONS, // <-- ADD/VERIFY THESE
} = require("./constants");
// ... other requires (ignore, tiktoken, excludedFiles, etc.) ...

// --- normalizePath function (Keep or verify it exists) ---
function normalizePath(filePath) {
  /* ... */
}

// --- Inside readFilesRecursively function ---
function readFilesRecursively(dir, rootDir, ignoreFilter) {
  rootDir = rootDir || dir;
  ignoreFilter = ignoreFilter || loadGitignore(rootDir);
  let results = [];

  try {
    const dirents = fs.readdirSync(dir, { withFileTypes: true });
    const directories = [];
    const files = [];

    dirents.forEach((dirent) => {
      const fullPath = path.join(dir, dirent.name);
      // Use relative path for ignore checks AND description checks
      const relativePath = path.relative(rootDir, fullPath);
      const relativePathNormalized = relativePath.replace(/\\/g, "/");

      // --- Ignore logic (Keep existing) ---
      if (ignoreFilter.ignores(relativePathNormalized)) return;
      // ... existing excludedFiles pattern checks ...

      if (dirent.isDirectory()) {
        directories.push(dirent);
      } else if (dirent.isFile()) {
        files.push({ dirent, fullPath, relativePathNormalized }); // Pass info along
      }
    });

    // Process directories recursively (Keep existing)
    directories.forEach((dirent) => {
      /* ... */
    });

    // Process files
    files.forEach(({ dirent, fullPath, relativePathNormalized }) => {
      // Use passed info
      try {
        const stats = fs.statSync(fullPath);
        const fileSize = stats.size;

        if (fileSize > MAX_FILE_SIZE) {
          /* Keep existing logic */ return;
        }

        const isBinary = isBinaryFile(fullPath);
        const fileContent = isBinary ? "" : fs.readFileSync(fullPath, "utf8");
        const tokenCount = isBinary ? 0 : countTokens(fileContent);

        // --- Identify Description/Overview Files ---
        let descriptionForSectionId = null;
        let isOverviewTemplate = false;
        let isProjectTreeDescription = false; // Flag for tree description
        const parentDirRelative = path.dirname(relativePathNormalized);

        // Check if the file is inside the descriptions directory
        if (parentDirRelative === DESCRIPTIONS_DIR) {
          if (dirent.name === OVERVIEW_FILENAME) {
            isOverviewTemplate = true;
          } else {
            // Check if it's a description for a defined section
            const matchingSection = PROMPT_SECTIONS.find(
              (s) => s.descriptionFilename === dirent.name
            );
            if (matchingSection) {
              descriptionForSectionId = matchingSection.id;
            }
            // Check if it's the description for the project tree
            else if (PROJECT_TREE_CONFIG.descriptionFilename === dirent.name) {
              isProjectTreeDescription = true;
            }
          }
        }
        // --- END Identification Logic ---

        results.push({
          name: dirent.name,
          path: fullPath, // Send original path, normalize before sending
          content: fileContent,
          tokenCount: tokenCount,
          size: fileSize,
          isBinary: isBinary,
          isSkipped: false,
          // --- Add New Flags ---
          descriptionForSectionId: descriptionForSectionId,
          isOverviewTemplate: isOverviewTemplate,
          isProjectTreeDescription: isProjectTreeDescription, // <-- Add this flag
          // --- End New Flags ---
          fileType: isBinary
            ? path.extname(fullPath).substring(1).toUpperCase()
            : null,
          excludedByDefault: shouldExcludeByDefault(fullPath, rootDir),
        });
      } catch (err) {
        /* Keep existing error handling */
      }
    });
  } catch (err) {
    /* Keep existing error handling */
  }

  return results;
}

// --- In the ipcMain.on(IPC_CHANNELS.REQUEST_FILE_LIST, ...) handler ---
// Before sending data back (event.sender.send):
const serializableFiles = files.map((file) => {
  const normalizedPath = normalizePath(file.path); // Normalize path *here*
  return {
    // ... keep existing properties (name, tokenCount, size, isBinary, etc.) ...
    path: normalizedPath, // SEND NORMALIZED PATH
    content: file.isBinary ? "" : String(file.content || ""), // Ensure string content
    // --- Ensure new flags are correctly included and typed ---
    descriptionForSectionId: file.descriptionForSectionId
      ? String(file.descriptionForSectionId)
      : null,
    isOverviewTemplate: Boolean(file.isOverviewTemplate),
    isProjectTreeDescription: Boolean(file.isProjectTreeDescription), // <-- Include this flag
  };
});

console.log(`Sending ${serializableFiles.length} files to renderer`);
// Log a sample of description/overview files found
const specialFiles = serializableFiles.filter(
  (f) =>
    f.descriptionForSectionId ||
    f.isOverviewTemplate ||
    f.isProjectTreeDescription
);
if (specialFiles.length > 0) {
  console.log(
    `Found ${specialFiles.length} special description/overview files:`
  );
  specialFiles
    .slice(0, 5)
    .forEach((f) =>
      console.log(
        `- ${f.path} (Overview: ${f.isOverviewTemplate}, DescFor: ${f.descriptionForSectionId}, TreeDesc: ${f.isProjectTreeDescription})`
      )
    );
}

event.sender.send(IPC_CHANNELS.FILE_LIST_DATA, serializableFiles); // Send only the array now
```

**Step 4: Update Frontend FileData Type**

- **File:** `src/types/FileTypes.ts`
- **Action:** Add the new optional properties.

```typescript
// src/types/FileTypes.ts
export interface FileData {
  // ... existing fields ...
  // --- Add/Update properties ---
  sectionId?: string; // Assigned by frontend categorization logic
  descriptionForSectionId?: string | null; // Received from main.js (e.g., 'rules', 'docs')
  isOverviewTemplate?: boolean; // Received from main.js
  isProjectTreeDescription?: boolean; // Received from main.js <-- ADD THIS
}
```

**Step 5: Modify Frontend App Component (`App.tsx`)**

- **File:** `src/App.tsx`
- **Action:** Add state, categorization, rewrite `getSelectedFilesContent`, add UI toggle.
- **Imports:** `useState`, `useEffect`, `useCallback`, constants, utils, types.

```typescript
// src/App.tsx
import React, { useState, useEffect, useCallback, useRef } from "react";
// ... other imports ...
import { FileData } from "./types/FileTypes";
// --- Add/Verify Imports ---
import {
  PROMPT_SECTIONS,
  PROMPT_MARKERS,
  PROJECT_TREE_CONFIG,
  LOCAL_STORAGE_KEYS,
  DEFAULT_INCLUDE_FILE_TREE_GLOBAL,
  DEFAULT_INCLUDE_PROMPT_OVERVIEW_GLOBAL,
} from "./constants";
import { PromptSectionDefinition } from "./types/promptConfigTypes"; // Import type
import {
  getRelativePath,
  generateAsciiFileTree,
  comparePathsStructurally,
  normalizePath,
} from "./utils/pathUtils";
import {
  loadProjectState,
  updateProjectProperty,
  saveProjectState,
} from "./utils/storageUtils"; // Verify imports
import FileTreeToggle from "./components/FileTreeToggle"; // Assuming reuse
// --- End Imports ---

const App = () => {
  // ... existing state (selectedFolder, allFiles, selectedFiles, sortOrder, etc.) ...

  // --- Update Initial State Loading for Toggles (Use Global Defaults) ---
  // Load per-project state FIRST
  const projectState = loadProjectState(selectedFolder);

  // Then load global toggle states from localStorage or defaults
  const [includeFileTree, setIncludeFileTree] = useState(() => {
    const saved = localStorage.getItem(LOCAL_STORAGE_KEYS.INCLUDE_FILE_TREE); // Use global key
    return saved ? JSON.parse(saved) : DEFAULT_INCLUDE_FILE_TREE_GLOBAL;
  });
  const [includePromptOverview, setIncludePromptOverview] = useState(() => {
    const saved = localStorage.getItem(
      LOCAL_STORAGE_KEYS.INCLUDE_PROMPT_OVERVIEW
    );
    return saved ? JSON.parse(saved) : DEFAULT_INCLUDE_PROMPT_OVERVIEW_GLOBAL;
  });

  // Update other state based on loaded *project* state
  const [selectedFiles, setSelectedFiles] = useState(
    projectState.selectedFiles
  );
  const [sortOrder, setSortOrder] = useState(projectState.sortOrder);
  // ... initialize other per-project states from projectState ...

  // --- Persist Global Toggle States ---
  useEffect(() => {
    localStorage.setItem(
      LOCAL_STORAGE_KEYS.INCLUDE_FILE_TREE,
      JSON.stringify(includeFileTree)
    );
  }, [includeFileTree]);
  useEffect(() => {
    localStorage.setItem(
      LOCAL_STORAGE_KEYS.INCLUDE_PROMPT_OVERVIEW,
      JSON.stringify(includePromptOverview)
    );
  }, [includePromptOverview]);

  // --- Persist Per-Project State (Keep existing useEffects for selectedFiles, sortOrder, etc.) ---
  // Example:
  useEffect(() => {
    updateProjectProperty(selectedFolder, "selectedFiles", selectedFiles);
  }, [selectedFiles, selectedFolder]);
  // ... other per-project persistence effects ...

  // --- Categorization Function ---
  const categorizeFile = useCallback(
    (file: FileData, currentSelectedFolder: string | null): string => {
      const defaultSection = PROMPT_SECTIONS.find((s) => s.directory === null);
      const defaultSectionId = defaultSection?.id || "project_files";

      // Special files don't get categorized by path for content sections
      if (
        file.descriptionForSectionId ||
        file.isOverviewTemplate ||
        file.isProjectTreeDescription ||
        !currentSelectedFolder
      ) {
        return defaultSectionId; // Assign default, won't be treated as content file anyway
      }

      const relativePath = getRelativePath(file.path, currentSelectedFolder);
      if (!relativePath) {
        return defaultSectionId;
      }

      for (const section of PROMPT_SECTIONS) {
        if (section.directory) {
          if (
            relativePath === section.directory ||
            relativePath.startsWith(section.directory + "/")
          ) {
            return section.id;
          }
        }
      }
      return defaultSectionId;
    },
    []
  );

  // --- Update useEffect for 'file-list-data' ---
  useEffect(() => {
    if (!window.electron) return;
    // ... (inside the useEffect)
    const handleFileListData = (receivedFiles: FileData[]) => {
      console.log("Received file list data:", receivedFiles.length, "files");
      const categorizedFiles = receivedFiles.map((file) => ({
        ...file,
        sectionId: categorizeFile(file, selectedFolder), // Pass current folder state
      }));
      setAllFiles(categorizedFiles);
      setProcessingStatus({ status: "complete" /* ... */ });
      applyFiltersAndSort(categorizedFiles, sortOrder, searchTerm); // Use updated state
    };
    window.electron.ipcRenderer.on("file-list-data", handleFileListData);
    // ... rest of setup/cleanup ...
  }, [
    selectedFolder,
    sortOrder,
    searchTerm,
    applyFiltersAndSort,
    categorizeFile /* Add categorizeFile */,
  ]);

  // --- Format Marker Helper ---
  const formatMarker = useCallback(
    (
      template: string,
      context: { section_name?: string; file_path?: string }
    ): string => {
      let result = template;
      if (context.section_name !== undefined)
        result = result.replace("{section_name}", context.section_name);
      if (context.file_path !== undefined)
        result = result.replace("{file_path}", context.file_path);
      return result;
    },
    []
  );

  // --- REWRITE getSelectedFilesContent ---
  const getSelectedFilesContent = useCallback(() => {
    // 1. Filter for *selected* files that are actual content (not binary, skipped, special)
    const contentFiles = allFiles.filter(
      (file) =>
        selectedFiles.includes(file.path) &&
        !file.isBinary &&
        !file.isSkipped &&
        !file.descriptionForSectionId &&
        !file.isOverviewTemplate &&
        !file.isProjectTreeDescription
    );

    // 2. Find special files (descriptions, overview) from *all* files
    const descriptionMap: Record<string, string> = {}; // Key: sectionId or 'project_tree'
    let overviewContent: string | null = null;
    allFiles.forEach((file) => {
      if (file.content) {
        // Ensure content exists
        if (file.descriptionForSectionId) {
          descriptionMap[file.descriptionForSectionId] = file.content;
        } else if (file.isProjectTreeDescription) {
          descriptionMap["project_tree"] = file.content; // Use special key
        } else if (file.isOverviewTemplate) {
          overviewContent = file.content;
        }
      }
    });

    // Early exit if nothing to output
    if (
      contentFiles.length === 0 &&
      !includeFileTree &&
      !includePromptOverview
    ) {
      return "No text files selected, or tree/overview not included.";
    }

    // 3. Sort content files based on UI settings
    const [sortKey, sortDir] = sortOrder.split("-");
    const sortedContentFiles = [...contentFiles].sort((a, b) => {
      let comparison = 0;
      if (sortKey === "name") comparison = a.name.localeCompare(b.name);
      else if (sortKey === "tokens") comparison = a.tokenCount - b.tokenCount;
      else if (sortKey === "size") comparison = a.size - b.size;
      else if (sortKey === "path")
        comparison = comparePathsStructurally(a.path, b.path, selectedFolder);
      return sortDir === "asc" ? comparison : -comparison;
    });

    // --- Build Output ---
    let output = "";
    const markers = PROMPT_MARKERS;

    // 4. Add Overview (if enabled and content exists)
    if (includePromptOverview && overviewContent) {
      output += overviewContent.trim() + "\n\n"; // Trim just in case, add spacing
    }

    // 5. Add Project Tree (if enabled)
    if (includeFileTree && selectedFolder) {
      const treeSectionName = PROJECT_TREE_CONFIG.name;
      const treeDescription = descriptionMap["project_tree"];

      output +=
        formatMarker(markers.section_open, { section_name: treeSectionName }) +
        "\n";
      if (treeDescription) {
        output += markers.description_open + "\n";
        output += treeDescription.trim() + "\n";
        output += markers.description_close + "\n";
      }
      // Generate tree from the *selected content* files
      const asciiTree = generateAsciiFileTree(
        sortedContentFiles,
        selectedFolder
      );
      output += selectedFolder + "\n";
      output += asciiTree + "\n";
      output +=
        formatMarker(markers.section_close, { section_name: treeSectionName }) +
        "\n\n";
    }

    // 6. Group sorted content files by sectionId
    const filesBySection: Record<string, FileData[]> = {};
    const defaultSectionId =
      PROMPT_SECTIONS.find((s) => s.directory === null)?.id || "project_files";
    sortedContentFiles.forEach((file) => {
      const sectionId = file.sectionId || defaultSectionId;
      if (!filesBySection[sectionId]) filesBySection[sectionId] = [];
      filesBySection[sectionId].push(file);
    });

    // 7. Iterate through sections IN DEFINED ORDER
    for (const section of PROMPT_SECTIONS) {
      const sectionFiles = filesBySection[section.id];
      if (!sectionFiles || sectionFiles.length === 0) continue; // Skip empty sections

      // --- Section Start ---
      output +=
        formatMarker(markers.section_open, { section_name: section.name }) +
        "\n";

      // --- Description ---
      const description = descriptionMap[section.id];
      if (description) {
        output += markers.description_open + "\n";
        output += description.trim() + "\n";
        output += markers.description_close + "\n";
      }

      // --- Files ---
      sectionFiles.forEach((file) => {
        const relativePath = getRelativePath(file.path, selectedFolder);
        output +=
          "\n" +
          formatMarker(markers.file_open, { file_path: relativePath }) +
          "\n";
        output += file.content; // Raw content
        if (file.content && !file.content.endsWith("\n")) output += "\n"; // Ensure newline before end marker
        output +=
          formatMarker(markers.file_close, { file_path: relativePath }) + "\n";
      });

      // --- Section End ---
      output +=
        "\n" +
        formatMarker(markers.section_close, { section_name: section.name }) +
        "\n\n";
    }

    return output.trim();
  }, [
    allFiles,
    selectedFiles,
    sortOrder,
    selectedFolder,
    includeFileTree,
    includePromptOverview,
    formatMarker,
  ]); // Dependencies

  // --- Add UI Toggle ---
  // Inside the main return statement, within <div className="copy-button-container">
  // Ensure FileTreeToggle component is imported or create a similar reusable toggle.
  /*
   <div className="copy-button-container">
       <FileTreeToggle
           checked={includePromptOverview}
           onChange={() => setIncludePromptOverview(!includePromptOverview)}
           title={includePromptOverview ? "Exclude prompt overview from output" : "Include prompt overview in output"}
       >
           <span>Include Overview</span>
       </FileTreeToggle>

       <FileTreeToggle
           checked={includeFileTree}
           onChange={() => setIncludeFileTree(!includeFileTree)}
           title={includeFileTree ? "Exclude file tree from output" : "Include file tree in output"}
       >
          <span>Include File Tree</span>
       </FileTreeToggle>

       <CopyButton
           text={getSelectedFilesContent()} // Pass the result of the function
           className="primary full-width copy-files-btn"
           // Add logic to disable button if getSelectedFilesContent() returns the "nothing selected" message?
           // isDisabled={getSelectedFilesContent().startsWith("No text files selected")} // Example disable logic
       >
           <span>COPY ({selectedFiles.length} files)</span>
       </CopyButton>
   </div>
  */
  // Make sure the JSX for the toggles and button is correctly placed within the return statement.
}; // End of App component
export default App;
```

**Step 6: Modify `FileList` Component**

- **File:** `src/components/FileList.tsx`
- **Action:** Update imports, filtering logic, and ensure section prop passing.

```typescript
// src/components/FileList.tsx
import React from "react";
import { FileListProps, FileData } from "../types/FileTypes";
import FileCard from "./FileCard";
import { normalizePath } from "../utils/pathUtils";
// --- Updated Imports ---
import { PROMPT_SECTIONS } from "../constants"; // Use constants
import { PromptSectionDefinition } from "../types/promptConfigTypes"; // Use types file
// --- End Updated Imports ---

interface ExtendedFileListProps extends FileListProps {
  view: "structured" | "flat";
}

const FileList = ({
  files, // Already filtered/sorted by App.tsx
  selectedFiles,
  toggleFileSelection,
  selectedFolder,
  view,
}: ExtendedFileListProps) => {
  const selectedPathsSet = new Set(selectedFiles.map(normalizePath)); // Keep using normalized paths for checking selection

  // Filter for files to *display* in the list (selected, not binary/skipped, not special description/overview files)
  const displayableFiles = files.filter(
    (file) =>
      selectedPathsSet.has(file.path) && // Already normalized? Ensure consistency
      !file.isBinary &&
      !file.isSkipped &&
      !file.descriptionForSectionId &&
      !file.isOverviewTemplate &&
      !file.isProjectTreeDescription // Exclude tree description too
  );

  // Grouping logic for structured view
  const filesBySection: Record<string, FileData[]> = {};
  if (view === "structured") {
    const defaultSectionId =
      PROMPT_SECTIONS.find((s) => s.directory === null)?.id || "project_files";
    displayableFiles.forEach((file) => {
      const sectionId = file.sectionId || defaultSectionId;
      if (!filesBySection[sectionId]) filesBySection[sectionId] = [];
      filesBySection[sectionId].push(file);
    });
  }

  // Helper to find section config for a file
  const findSectionConfig = (
    file: FileData
  ): PromptSectionDefinition | undefined => {
    const defaultSectionId =
      PROMPT_SECTIONS.find((s) => s.directory === null)?.id || "project_files";
    return PROMPT_SECTIONS.find(
      (s) => s.id === (file.sectionId || defaultSectionId)
    );
  };

  // Render Flat View
  const renderFlatView = () => (
    <div className={`file-list view-flat`}>
      {displayableFiles.map((file: FileData) => (
        <FileCard
          key={file.path}
          file={file}
          isSelected={true}
          toggleSelection={toggleFileSelection}
          selectedFolder={selectedFolder}
          section={findSectionConfig(file)} // Pass resolved section object
        />
      ))}
    </div>
  );

  // Render Structured View
  const renderStructuredView = () => (
    <div className={`file-list-structured`}>
      {PROMPT_SECTIONS.map((sectionConfig) => {
        // Iterate in constant order
        const sectionFiles = filesBySection[sectionConfig.id];
        if (!sectionFiles || sectionFiles.length === 0) return null;

        return (
          <div
            key={sectionConfig.id}
            className="file-list-section"
            style={{
              borderLeft: `3px solid ${sectionConfig.color || "transparent"}`,
            }}
          >
            <div
              className="file-list-section-header"
              style={{
                backgroundColor: sectionConfig.color
                  ? `${sectionConfig.color}20`
                  : "transparent",
              }}
            >
              {sectionConfig.label} ({sectionFiles.length})
              {/* Description icon removed as descriptions are not shown directly in UI */}
            </div>
            <div className="file-list view-structured-items">
              {/* Files are already sorted by App.tsx sortOrder */}
              {sectionFiles.map((file: FileData) => (
                <FileCard
                  key={file.path}
                  file={file}
                  isSelected={true}
                  toggleSelection={toggleFileSelection}
                  selectedFolder={selectedFolder}
                  section={sectionConfig} // Pass the current section config
                />
              ))}
            </div>
          </div>
        );
      })}
    </div>
  );

  // Return logic
  return (
    <div className="file-list-container">
      {displayableFiles.length > 0 ? (
        view === "flat" ? (
          renderFlatView()
        ) : (
          renderStructuredView()
        )
      ) : (
        <div className="file-list-empty">
          {files.length > 0 // Check original files length passed down
            ? "No content file is selected, or selected files are descriptions/overview."
            : selectedFolder
            ? "The loaded folder is empty or all files were filtered out."
            : "Select a folder to display files."}
        </div>
      )}
    </div>
  );
};

export default FileList;
```

**Step 7: Update `FileCard` Component**

- **File:** `src/components/FileCard.tsx`
- **Action:** Update type import path. No other functional changes required.

```typescript
// src/components/FileCard.tsx
import React from "react";
// ... other imports ...
import { FileText } from "lucide-react"; // Keep
import { getRelativePath } from "../utils/pathUtils"; // Keep
// --- UPDATE IMPORT PATH ---
import { PromptSectionDefinition } from "../types/promptConfigTypes"; // Adjust path if needed
// --- END UPDATE ---

interface FileCardComponentProps {
  file: {
    /* ... */
  };
  isSelected: boolean;
  toggleSelection: (path: string) => void;
  selectedFolder: string | null;
  section?: PromptSectionDefinition; // Type from the new file
}

const FileCard = ({ /* ... props ... */ section }: FileCardComponentProps) => {
  // ... existing destructuring ...
  const relativePath = getRelativePath(filePath, selectedFolder);

  return (
    <div
      className={`file-card ${isSelected ? "selected" : ""}`}
      style={{
        borderLeft: section
          ? `4px solid ${section.color}`
          : "1px solid var(--border-color)",
        paddingLeft: section ? "7px" : "10px",
      }}
    >
      {/* ... FileCard header ... */}
      <div className="file-card-info">
        <div className="file-card-path">
          <span title={relativePath}>{relativePath}</span>
        </div>
      </div>
      <div className="file-card-info">
        <div className="file-card-tokens">
          <span className="tokens-count">~{formattedTokens} tokens</span>
          {/* --- Use section label and color --- */}
          {section ? (
            <span
              className="file-type"
              style={{ color: section.color, fontWeight: 500 }}
            >
              {section.label}
            </span>
          ) : (
            <span className="file-type"></span> // Fallback empty span
          )}
          {/* --- End Update --- */}
        </div>
      </div>
      {/* ... FileCard actions ... */}
    </div>
  );
};

export default FileCard;
```

**Step 8: Add CSS Styles (`index.css`)**

- **File:** `src/styles/index.css`
- **Action:** Add the CSS rules provided in the previous detailed plan for `.file-list-structured`, `.file-list-section`, `.file-list-section-header`, and `.file-list.view-structured-items`. Ensure the file type styling in `.file-card .file-type` doesn't conflict.

**Step 9: Update Storage Utilities (`storageUtils.ts`)**

- **File:** `src/utils/storageUtils.ts`
- **Action:** No changes needed here based on the latest plan. Global settings are handled directly in `App.tsx` with `localStorage`. Per-project settings logic remains the same.

**Step 10: Testing Checklist**

- **Core Functionality:** Select folder, see sidebar, select/deselect files/folders, flat view works, filtering/sorting in flat view works, basic copy (without new features) works.
- **Structured View:**
  - Switch to Structured view.
  - Files appear grouped under correct section headers (Rules, Docs, Project, Prompts).
  - Section headers show correct label and file count.
  - File cards within sections have the correct colored left border and section label.
  - Sorting applies _within_ each section.
  - Files not belonging to `ai/rules`, `ai/docs`, `ai/prompts` appear under "Project".
  - Description/overview files (`*.txt` in `ai/.descriptions`) DO NOT appear in the UI list.
  - Empty sections are not rendered.
- **Output Generation:**
  - **Overview:** Checkbox controls inclusion; content matches `overview.txt`.
  - **Tree:** Checkbox controls inclusion; structure matches selected files; description included if `project_tree.txt` exists.
  - **Sections:** Appear only if selected files exist for them; appear in the correct order (`PROMPT_SECTIONS`); markers (`@@@@`) are correct.
  - **Descriptions:** Included within sections only if `[section_id].txt` exists; markers (`%%%%`) are correct.
  - **Files:** Included within correct sections; markers (`>>>>`) are correct; relative paths are correct; content is accurate.
  - Test combinations: only project files selected, only rules selected, rules+project selected, etc.
  - Test empty description/overview files.
- **State Persistence:** Global toggle states (Overview, Tree) persist across app restarts. Per-project state (selected files, sort order) persists when switching folders and restarting.

---

Agent, please implement these steps carefully. Pay attention to imports, state management dependencies, and the logic within `getSelectedFilesContent` and `FileList`. Use DRY principles and maintain code clarity. Good luck!
